import asyncio\nimport unittest\nfrom typing import TypeVar, Any, cast\nfrom gloe import (\n    async_transformer,\n    ensure,\n    UnsupportedTransformerArgException,\n    transformer,\n    AsyncTransformer,\n    TransformerException,\n)\nfrom gloe.async_transformer import _execute_async_flow\nfrom gloe.functional import partial_async_transformer\nfrom gloe.utils import forward\nfrom tests.lib.ensurers import is_odd\nfrom tests.lib.exceptions import LnOfNegativeNumber, NumbersEqual, NumberIsEven\nfrom tests.lib.transformers import async_plus1, async_natural_logarithm, minus1\n_In = TypeVar("_In")\n_DATA = {"foo": "bar"}\nasync def raise_an_error():\n    await asyncio.sleep(0.1)\n    raise NotImplementedError()\n@async_transformer\nasync def request_data(url: str) -> dict[str, str]:\n    await asyncio.sleep(0.01)\n    return _DATA\nclass RequestData(AsyncTransformer[str, dict[str, str]]):\n    async def transform_async(self, url: str) -> dict[str, str]:\n        await asyncio.sleep(0.01)\n        return _DATA\nclass HasNotBarKey(Exception):\n    pass\nclass HasNotFooKey(Exception):\n    pass\nclass HasFooKey(Exception):\n    pass\nclass IsNotInt(Exception):\n    pass\ndef has_bar_key(data: dict[str, str]):\n    if "bar" not in data.keys():\n        raise HasNotBarKey()\ndef has_foo_key(data: dict[str, str]):\n    if "foo" not in data.keys():\n        raise HasNotBarKey()\ndef is_int(data: Any):\n    if type(data) is not int:\n        raise IsNotInt()\ndef is_str(data: Any):\n    if type(data) is not str:\n        raise Exception("data is not string")\ndef foo_key_removed(incoming: dict[str, str], outcome: dict[str, str]):\n    if "foo" not in incoming.keys():\n        raise HasNotFooKey()\n    if "foo" in outcome.keys():\n        raise HasFooKey()\n_URL = "http://my-service"\nclass TestAsyncTransformer(unittest.IsolatedAsyncioTestCase):\n    async def test_basic_case(self):\n        test_forward = request_data >> forward()\n        result = await test_forward(_URL)\n        self.assertDictEqual(_DATA, result)\n    async def test_begin_with_transformer(self):\n        test_forward = forward[str]() >> request_data\n        result = await test_forward(_URL)\n        self.assertDictEqual(_DATA, result)\n    async def test_async_on_divergent_connection(self):\n        test_forward = forward[str]() >> (forward[str](), request_data)\n        result = await test_forward(_URL)\n        self.assertEqual((_URL, _DATA), result)\n    async def test_divergent_connection_from_async(self):\n        test_forward = request_data >> (forward[dict[str, str]](), forward[dict[str, str]]())\n        result = await test_forward(_URL)\n        self.assertEqual((_DATA, _DATA), result)\n    async def test_async_transformer_wrong_arg(self):\n        def next_transformer():\n            pass\n        @ensure(outcome=[has_bar_key])\n        @partial_async_transformer\n        async def ensured_delayed_request(url: str, delay: float) -> dict[str, str]:\n            await asyncio.sleep(delay)\n            return _DATA\n        with self.assertRaises(UnsupportedTransformerArgException):\n            ensured_delayed_request(0.01) >> next_transformer  # type: ignore\n    async def test_async_transformer_copy(self):\n        @transformer\n        def add_slash(path: str) -> str:\n            return path + "/"\n        @partial_async_transformer\n        async def ensured_delayed_request(url: str, delay: float) -> dict[str, str]:\n            await asyncio.sleep(delay)\n            return _DATA\n        pipeline = add_slash >> ensured_delayed_request(0)\n        pipeline = pipeline.copy()\n        result = await pipeline(_URL)\n        self.assertEqual(_DATA, result)\n    def test_async_transformer_wrong_signature(self):\n        with self.assertWarns(RuntimeWarning):\n            @async_transformer  # type: ignore\n            async def many_args(arg1: str, arg2: int):\n                await asyncio.sleep(1)\n                return arg1, arg2\n    def test_async_transformer_signature_representation(self):\n        signature = request_data.signature()\n        self.assertEqual(str(signature), "(url: str) -> dict[str, str]")\n    def test_async_transformer_representation(self):\n        self.assertEqual(repr(request_data), "str -> (request_data) -> dict[str, str]")\n        class_request_data = RequestData()\n        self.assertEqual(repr(class_request_data), "str -> (RequestData) -> dict[str, str]")\n        @transformer\n        def dict_to_str(_dict: dict) -> str:\n            return str(_dict)\n        request_and_serialize = request_data >> dict_to_str\n        self.assertEqual(repr(request_and_serialize), "dict -> (2 transformers omitted) -> str")\n    async def test_exhausting_large_flow(self):\n        graph = async_plus1\n        max_iters = 1500\n        for i in range(max_iters):\n            graph = graph >> async_plus1\n        result = await graph(0)\n        self.assertEqual(result, max_iters + 1)\n    async def test_async_transformer_error_handling(self):\n        async_graph = async_plus1 >> async_natural_logarithm\n        try:\n            await async_graph(-2)\n        except LnOfNegativeNumber as exception:\n            self.assertEqual(type(exception.__cause__), TransformerException)\n            exception_ctx = cast(TransformerException, exception.__cause__)\n            self.assertEqual(async_natural_logarithm, exception_ctx.raiser_transformer)\n    async def test_execute_async_wrong_flow(self):\n        flow = [2]\n        with self.assertRaises(NotImplementedError):\n            await _execute_async_flow(flow, 1)  # type: ignore\n    async def test_composition_transform_method(self):\n        test3 = forward[float]() >> async_plus1\n        result = await test3.transform_async(5)\n        self.assertIsNone(result)\n        test2 = forward[float]() >> (async_plus1, async_plus1)\n        result2 = await test2.transform_async(5)\n        self.assertIsNone(result2)\