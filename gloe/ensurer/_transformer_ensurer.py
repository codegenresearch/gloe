import inspect\nfrom abc import abstractmethod, ABC\nfrom types import FunctionType\nfrom typing import Any, Callable, Generic, ParamSpec, Sequence, TypeVar, cast, overload\n\nfrom gloe.async_transformer import AsyncTransformer\nfrom gloe.functional import _PartialTransformer, _PartialAsyncTransformer\nfrom gloe.transformers import Transformer\n\n_T = TypeVar("_T")\n_S = TypeVar("_S")\n_U = TypeVar("_U")\n_P1 = ParamSpec("_P1")\n\nclass TransformerEnsurer(Generic[_T, _S], ABC):\n    \"\"\"Base class for ensuring data validation in transformers.\n\n    This class provides a framework for validating input and output data in transformers.\n    Subclasses must implement the `validate_input` and `validate_output` methods.\n    \"\"\"\n    @abstractmethod\n    def validate_input(self, data: _T):\n        \"\"\"Validate incoming data before executing the transformer.\n\n        Args:\n            data (_T): The input data to be validated.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def validate_output(self, data: _T, output: _S):\n        \"\"\"Validate outcome data after executing the transformer.\n\n        Args:\n            data (_T): The input data that was transformed.\n            output (_S): The output data to be validated.\n        \"\"\"\n        pass\n\n    def __call__(self, transformer: Transformer[_T, _S]) -> Transformer[_T, _S]:\n        def transform(this: Transformer, data: _T) -> _S:\n            self.validate_input(data)\n            output = transformer.transform(data)\n            self.validate_output(data, output)\n            return output\n\n        transformer_cp = transformer.copy(transform)\n        return transformer_cp\n\ndef input_ensurer(func: Callable[[_T], Any]) -> TransformerEnsurer[_T, Any]:\n    class LambdaEnsurer(TransformerEnsurer[_T, _S]):\n        __doc__ = func.__doc__\n        __annotations__ = cast(FunctionType, func).__annotations__\n\n        def validate_input(self, data: _T):\n            func(data)\n\n        def validate_output(self, data: _T, output: _S):\n            pass\n\n    return LambdaEnsurer()\n\n@overload\ndef output_ensurer(func: Callable[[_T, _S], Any]) -> TransformerEnsurer[_T, _S]:\n    pass\n\n@overload\ndef output_ensurer(func: Callable[[_S], Any]) -> TransformerEnsurer[Any, _S]:\n    pass\n\ndef output_ensurer(func: Callable):\n    class LambdaEnsurer(TransformerEnsurer):\n        __doc__ = func.__doc__\n        __annotations__ = cast(FunctionType, func).__annotations__\n\n        def validate_input(self, data):\n            pass\n\n        def validate_output(self, data, output):\n            if len(inspect.signature(func).parameters) == 1:\n                func(output)\n            else:\n                func(data, output)\n\n    return LambdaEnsurer()\n\nclass _ensure_base:\n    @overload\n    def __call__(self, transformer: Transformer[_U, _S]) -> Transformer[_U, _S]:\n        pass\n\n    @overload\n    def __call__(self, transformer_init: _PartialTransformer[_T, _P1, _U]) -> _PartialTransformer[_T, _P1, _U]:\n        pass\n\n    @overload\n    def __call__(self, transformer: AsyncTransformer[_U, _S]) -> AsyncTransformer[_U, _S]:\n        pass\n\n    @overload\n    def __call__(self, transformer_init: _PartialAsyncTransformer[_T, _P1, _U]) -> _PartialAsyncTransformer[_T, _P1, _U]:\n        pass\n\n    def __call__(self, arg):\n        if isinstance(arg, Transformer):\n            return self._generate_new_transformer(arg)\n        elif isinstance(arg, AsyncTransformer):\n            return self._generate_new_async_transformer(arg)\n        elif isinstance(arg, _PartialTransformer):\n            transformer_init = arg\n\n            def ensured_transformer_init(*args, **kwargs):\n                transformer = transformer_init(*args, **kwargs)\n                return self._generate_new_transformer(transformer)\n\n            return ensured_transformer_init\n        elif isinstance(arg, _PartialAsyncTransformer):\n            async_transformer_init = arg\n\n            def ensured_async_transformer_init(*args, **kwargs):\n                async_transformer = async_transformer_init(*args, **kwargs)\n                return self._generate_new_async_transformer(async_transformer)\n\n            return ensured_async_transformer_init\n\n    @abstractmethod\n    def _generate_new_transformer(self, transformer: Transformer) -> Transformer:\n        pass\n\n    @abstractmethod\n    def _generate_new_async_transformer(self, transformer: AsyncTransformer) -> AsyncTransformer:\n        pass\n\nclass _ensure_incoming(Generic[_T], _ensure_base):\n    def __init__(self, incoming: Sequence[Callable[[_T], Any]]):\n        self.input_ensurers_instances = [input_ensurer(ensurer) for ensurer in incoming]\n\n    def _generate_new_transformer(self, transformer: Transformer) -> Transformer:\n        def transform(_, data):\n            for ensurer in self.input_ensurers_instances:\n                ensurer.validate_input(data)\n            output = transformer.transform(data)\n            return output\n\n        transformer_cp = transformer.copy(transform)\n        return transformer_cp\n\n    def _generate_new_async_transformer(self, transformer: AsyncTransformer) -> AsyncTransformer:\n        async def transform_async(_, data):\n            for ensurer in self.input_ensurers_instances:\n                ensurer.validate_input(data)\n            output = await transformer.transform_async(data)\n            return output\n\n        transformer_cp = transformer.copy(transform_async)\n        return transformer_cp\n\nclass _ensure_outcome(Generic[_S], _ensure_base):\n    def __init__(self, outcome: Sequence[Callable[[_S], Any]]):\n        self.output_ensurers_instances = [output_ensurer(ensurer) for ensurer in outcome]\n\n    def _generate_new_transformer(self, transformer: Transformer) -> Transformer:\n        def transform(_, data):\n            output = transformer.transform(data)\n            for ensurer in self.output_ensurers_instances:\n                ensurer.validate_output(data, output)\n            return output\n\n        transformer_cp = transformer.copy(transform)\n        return transformer_cp\n\n    def _generate_new_async_transformer(self, transformer: AsyncTransformer) -> AsyncTransformer:\n        async def transform_async(_, data):\n            output = await transformer.transform_async(data)\n            for ensurer in self.output_ensurers_instances:\n                ensurer.validate_output(data, output)\n            return output\n\n        transformer_cp = transformer.copy(transform_async)\n        return transformer_cp\n\nclass _ensure_changes(Generic[_T, _S], _ensure_base):\n    def __init__(self, changes: Sequence[Callable[[_T, _S], Any]]):\n        self.changes_ensurers_instances = [output_ensurer(ensurer) for ensurer in changes]\n\n    def _generate_new_transformer(self, transformer: Transformer) -> Transformer:\n        def transform(_, data):\n            output = transformer.transform(data)\n            for ensurer in self.changes_ensurers_instances:\n                ensurer.validate_output(data, output)\n            return output\n\n        transformer_cp = transformer.copy(transform)\n        return transformer_cp\n\n    def _generate_new_async_transformer(self, transformer: AsyncTransformer) -> AsyncTransformer:\n        async def transform_async(_, data):\n            output = await transformer.transform_async(data)\n            for ensurer in self.changes_ensurers_instances:\n                ensurer.validate_output(data, output)\n            return output\n\n        transformer_cp = transformer.copy(transform_async)\n        return transformer_cp\n\nclass _ensure_both(Generic[_T, _S], _ensure_base):\n    def __init__(\n        self,\n        incoming: Sequence[Callable[[_T], Any]],\n        outcome: Sequence[Callable[[_S], Any]],\n        changes: Sequence[Callable[[_T, _S], Any]],\n    ):\n        self.input_ensurers_instances = [input_ensurer(ensurer) for ensurer in incoming]\n        self.output_ensurers_instances = [output_ensurer(ensurer) for ensurer in outcome]\n        self.output_ensurers_instances.extend([output_ensurer(ensurer) for ensurer in changes])\n\n    def _generate_new_transformer(self, transformer: Transformer) -> Transformer:\n        def transform(_, data):\n            for ensurer in self.input_ensurers_instances:\n                ensurer.validate_input(data)\n            output = transformer.transform(data)\n            for ensurer in self.output_ensurers_instances:\n                ensurer.validate_output(data, output)\n            return output\n\n        transformer_cp = transformer.copy(transform)\n        return transformer_cp\n\n    def _generate_new_async_transformer(self, transformer: AsyncTransformer) -> AsyncTransformer:\n        async def transform_async(_, data):\n            for ensurer in self.input_ensurers_instances:\n                ensurer.validate_input(data)\n            output = await transformer.transform_async(data)\n            for ensurer in self.output_ensurers_instances:\n                ensurer.validate_output(data, output)\n            return output\n\n        transformer_cp = transformer.copy(transform_async)\n        return transformer_cp\n\n@overload\ndef ensure(incoming: Callable[[_T], Any]) -> _ensure_incoming[_T]:\n    pass\n\n@overload\ndef ensure(incoming: Sequence[Callable[[_T], Any]]) -> _ensure_incoming[_T]:\n    pass\n\n@overload\ndef ensure(outcome: Callable[[_S], Any]) -> _ensure_outcome[_S]:\n    pass\n\n@overload\ndef ensure(outcome: Sequence[Callable[[_S], Any]]) -> _ensure_outcome[_S]:\n    pass\n\n@overload\ndef ensure(changes: Callable[[_T, _S], Any]) -> _ensure_changes[_T, _S]:\n    pass\n\n@overload\ndef ensure(changes: Sequence[Callable[[_T, _S], Any]]) -> _ensure_changes[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Callable[[_T], Any], outcome: Callable[[_S], Any]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Callable[[_T], Any], outcome: Sequence[Callable[[_S], Any]]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Sequence[Callable[[_T], Any]], outcome: Callable[[_S], Any]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Sequence[Callable[[_T], Any]], outcome: Sequence[Callable[[_S], Any]]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Callable[[_T], Any], changes: Callable[[_T, _S], Any]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Callable[[_T], Any], changes: Sequence[Callable[[_T, _S], Any]]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Sequence[Callable[[_T], Any]], changes: Callable[[_T, _S], Any]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Sequence[Callable[[_T], Any]], changes: Sequence[Callable[[_T, _S], Any]]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(outcome: Callable[[_S], Any], changes: Callable[[_T, _S], Any]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(outcome: Callable[[_S], Any], changes: Sequence[Callable[[_T, _S], Any]]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(outcome: Sequence[Callable[[_S], Any]], changes: Callable[[_T, _S], Any]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(outcome: Sequence[Callable[[_S], Any]], changes: Sequence[Callable[[_T, _S], Any]]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Callable[[_T], Any], outcome: Callable[[_S], Any], changes: Callable[[_T, _S], Any]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Callable[[_T], Any], outcome: Callable[[_S], Any], changes: Sequence[Callable[[_T, _S], Any]]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Callable[[_T], Any], outcome: Sequence[Callable[[_S], Any]], changes: Callable[[_T, _S], Any]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Callable[[_T], Any], outcome: Sequence[Callable[[_S], Any]], changes: Sequence[Callable[[_T, _S], Any]]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Sequence[Callable[[_T], Any]], outcome: Callable[[_S], Any], changes: Callable[[_T, _S], Any]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Sequence[Callable[[_T], Any]], outcome: Callable[[_S], Any], changes: Sequence[Callable[[_T, _S], Any]]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Sequence[Callable[[_T], Any]], outcome: Sequence[Callable[[_S], Any]], changes: Callable[[_T, _S], Any]) -> _ensure_both[_T, _S]:\n    pass\n\n@overload\ndef ensure(incoming: Sequence[Callable[[_T], Any]], outcome: Sequence[Callable[[_S], Any]], changes: Sequence[Callable[[_T, _S], Any]]) -> _ensure_both[_T, _S]:\n    pass\n\ndef ensure(*args, **kwargs):\n    \"\"\"Decorator to ensure data validation in transformers.\n\n    This decorator allows specifying validators for incoming data, outcome data, or both.\n    Validators are callable functions that perform validation and raise exceptions if validation fails.\n\n    Args:\n        incoming (Callable[[_T], Any] or Sequence[Callable[[_T], Any]]): Validators for incoming data.\n        outcome (Callable[[_S], Any] or Sequence[Callable[[_S], Any]]): Validators for outcome data.\n        changes (Callable[[_T, _S], Any] or Sequence[Callable[[_T, _S], Any]]): Validators for both incoming and outcome data.\n\n    Returns:\n        An instance of a subclass of `_ensure_base` that applies the specified validations.\n    \"\"\"\n    def normalize_input(input_data):\n        if callable(input_data):\n            return [input_data]\n        return input_data\n\n    incoming = normalize_input(kwargs.get("incoming", []))\n    outcome = normalize_input(kwargs.get("outcome", []))\n    changes = normalize_input(kwargs.get("changes", []))\n\n    if incoming and not outcome and not changes:\n        return _ensure_incoming(incoming)\n    elif outcome and not incoming and not changes:\n        return _ensure_outcome(outcome)\n    elif changes and not incoming and not outcome:\n        return _ensure_changes(changes)\n    else:\n        return _ensure_both(incoming, outcome, changes)\n