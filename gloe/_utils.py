from functools import wraps, partial\nfrom types import GenericAlias, _GenericAlias\nfrom typing import (\n    TypeVar,\n    get_origin,\n    TypeAlias,\n    ParamSpec,\n    Callable,\n    Awaitable,\n    cast,\n)\nfrom inspect import signature, Signature\n\n\nclass TypeMismatchError(Exception):\n    """Exception raised when types do not match."""\n    def __init__(self, generic, specific):\n        self.generic = generic\n        self.specific = specific\n        super().__init__(f"Type {generic} does not match with {specific}")\n\n\ndef _format_annotation(annotation, generic_input_param, input_annotation):\n    if isinstance(annotation, str):\n        return annotation\n    if isinstance(annotation, tuple):\n        return f"({', '.join(_format_annotation(a, generic_input_param, input_annotation) for a in annotation)})"\n    if annotation.__name__ in {\"tuple\", \"Tuple\"}:\n        return f"({', '.join(_format_annotation(a, generic_input_param, input_annotation) for a in annotation.__args__)})"\n    if annotation.__name__ in {\"Union\"}:\n        return f"({' | '.join(_format_annotation(a, generic_input_param, input_annotation) for a in annotation.__args__)})"\n    if isinstance(annotation, GenericAlias) or isinstance(annotation, _GenericAlias):\n        return f"{annotation.__name__}[{', '.join(_format_annotation(a, generic_input_param, input_annotation) for a in annotation.__args__)}]"\n    if annotation == generic_input_param:\n        return input_annotation.__name__\n    return annotation.__name__\n\n\ndef _match_types(generic, specific, ignore_mismatches=True):\n    if type(generic) == TypeVar:\n        return {generic: specific}\n\n    specific_origin = get_origin(specific)\n    generic_origin = get_origin(generic)\n\n    if specific_origin is None and generic_origin is None:\n        return {}\n\n    if (specific_origin is None or generic_origin is None) or not issubclass(specific_origin, generic_origin):\n        if ignore_mismatches:\n            return {}\n        raise TypeMismatchError(generic, specific)\n\n    generic_args = getattr(generic, \"__args__\", None)\n    specific_args = getattr(specific, \"__args__\", None)\n\n    if specific_args is None and specific_args is None:\n        return {}\n\n    if generic_args is None:\n        if ignore_mismatches:\n            return {}\n        raise TypeMismatchError(generic, specific)\n\n    if specific_args is None:\n        if ignore_mismatches:\n            return {}\n        raise TypeMismatchError(generic, specific)\n\n    if len(generic_args) != len(specific_args):\n        if ignore_mismatches:\n            return {}\n        raise TypeMismatchError(generic, specific)\n\n    matches = {}\n    for generic_arg, specific_arg in zip(generic_args, specific_args):\n        matched_types = _match_types(generic_arg, specific_arg)\n        matches.update(matched_types)\n\n    return matches\n\n\ndef _specify_types(generic, spec):\n    if type(generic) == TypeVar:\n        tp = spec.get(generic)\n        if tp is None:\n            return generic\n        return tp\n\n    generic_args = getattr(generic, \"__args__\", None)\n\n    if generic_args is None:\n        return generic\n\n    origin = get_origin(generic)\n\n    args = tuple(_specify_types(arg, spec) for arg in generic_args)\n\n    return GenericAlias(origin, args)\n\n\n_Args = ParamSpec(\"_Args\")\n_R = TypeVar(\"_R\")\n\ndef awaitify(sync_func: Callable[_Args, _R]) -> Callable[_Args, Awaitable[_R]]:\n    async def async_func(*args: _Args.args, **kwargs: _Args.kwargs) -> _R:\n        return sync_func(*args, **kwargs)\n\n    return async_func\n