from functools import wraps, partial\nfrom types import GenericAlias, _GenericAlias\nfrom typing import (\n    TypeVar,\n    get_origin,\n    ParamSpec,\n    Callable,\n    Awaitable,\n    cast,\n)\nfrom inspect import signature, Signature\n\n\nclass TypeMismatchError(Exception):\n    """Exception raised when types do not match."""\n    def __init__(self, generic, specific):\n        self.generic = generic\n        self.specific = specific\n        super().__init__(f"Type {generic} does not match with {specific}")\n\n\ndef format_tuple_annotation(tuple_annotation, generic_input_param, input_annotation):\n    return f"({', '.join(format_annotation(a, generic_input_param, input_annotation) for a in tuple_annotation)})"\n\ndef format_union_annotation(union_annotation, generic_input_param, input_annotation):\n    return f"({' | '.join(format_annotation(a, generic_input_param, input_annotation) for a in union_annotation)})"\n\ndef format_generic_alias_annotation(generic_alias, generic_input_param, input_annotation):\n    return f"{generic_alias.__name__}[{', '.join(format_annotation(a, generic_input_param, input_annotation) for a in generic_alias.__args__)}]"\n\ndef format_annotation(annotation, generic_input_param, input_annotation):\n    if type(annotation) == str:\n        return annotation\n    if type(annotation) == tuple:\n        return format_tuple_annotation(annotation, generic_input_param, input_annotation)\n    if annotation.__name__ in {"tuple", "Tuple"}:\n        return format_tuple_annotation(annotation.__args__, generic_input_param, input_annotation)\n    if annotation.__name__ in {"Union"}:\n        return format_union_annotation(annotation.__args__, generic_input_param, input_annotation)\n    if type(annotation) == GenericAlias or type(annotation) == _GenericAlias:\n        return format_generic_alias_annotation(annotation, generic_input_param, input_annotation)\n    if annotation == generic_input_param:\n        return input_annotation.__name__\n    return annotation.__name__\n\ndef match_types(generic, specific, ignore_mismatches=True):\n    if type(generic) == TypeVar:\n        return {generic: specific}\n\n    specific_origin = get_origin(specific)\n    generic_origin = get_origin(generic)\n\n    if specific_origin is None and generic_origin is None:\n        return {}\n\n    if (specific_origin is None or generic_origin is None) or not issubclass(specific_origin, generic_origin):\n        if ignore_mismatches:\n            return {}\n        raise TypeMismatchError(generic, specific)\n\n    generic_args = getattr(generic, "__args__", None)\n    specific_args = getattr(specific, "__args__", None)\n\n    if specific_args is None and specific_args is None:\n        return {}\n\n    if generic_args is None:\n        if ignore_mismatches:\n            return {}\n        raise TypeMismatchError(generic, specific)\n\n    if specific_args is None:\n        if ignore_mismatches:\n            return {}\n        raise TypeMismatchError(generic, specific)\n\n    if len(generic_args) != len(specific_args):\n        if ignore_mismatches:\n            return {}\n        raise TypeMismatchError(generic, specific)\n\n    matches = {}\n    for generic_arg, specific_arg in zip(generic_args, specific_args):\n        matched_types = match_types(generic_arg, specific_arg)\n        matches.update(matched_types)\n\n    return matches\n\ndef specify_types(generic, spec):\n    if type(generic) == TypeVar:\n        tp = spec.get(generic)\n        if tp is None:\n            return generic\n        return tp\n\n    generic_args = getattr(generic, "__args__", None)\n\n    if generic_args is None:\n        return generic\n\n    origin = get_origin(generic)\n\n    args = tuple(specify_types(arg, spec) for arg in generic_args)\n\n    return GenericAlias(origin, args)\n\nArgs = ParamSpec("Args")\nR = TypeVar("R")\n\ndef convert_to_async(sync_func: Callable[Args, R]) -> Callable[Args, Awaitable[R]]:\n    async def async_wrapper(*args: Args.args, **kwargs: Args.kwargs) -> R:\n        return sync_func(*args, **kwargs)\n\n    return async_wrapper\n