from functools import wraps\nfrom types import GenericAlias\nfrom typing import (\n    TypeVar,\n    get_origin,\n    TypeAlias,\n    TypedDict,\n    Generic,\n    Union,\n    _GenericAlias,\n    ParamSpec,\n    Callable,\n    Awaitable,\n)  # type: ignore\n\ndef _format_tuple(tuple_annotation: tuple, generic_input_param, input_annotation) -> str:\n    return f"({', '.join(_format_return_annotation(a, generic_input_param, input_annotation) for a in tuple_annotation)})"\n\ndef _format_union(tuple_annotation: tuple, generic_input_param, input_annotation) -> str:\n    return f"({' | '.join(_format_return_annotation(a, generic_input_param, input_annotation) for a in tuple_annotation)})"\n\ndef _format_generic_alias(return_annotation: GenericAlias, generic_input_param, input_annotation) -> str:\n    alias_name = return_annotation.__name__\n    return f"{alias_name}[{', '.join(_format_return_annotation(a, generic_input_param, input_annotation) for a in return_annotation.__args__)}]"\n\ndef _format_return_annotation(return_annotation, generic_input_param, input_annotation) -> str:\n    if isinstance(return_annotation, str):\n        return return_annotation\n    if isinstance(return_annotation, tuple):\n        return _format_tuple(return_annotation, generic_input_param, input_annotation)\n    if return_annotation.__name__ in {"tuple", "Tuple"}:\n        return _format_tuple(return_annotation.__args__, generic_input_param, input_annotation)\n    if return_annotation.__name__ in {"Union"}:\n        return _format_union(return_annotation.__args__, generic_input_param, input_annotation)\n    if isinstance(return_annotation, (GenericAlias, _GenericAlias)):\n        return _format_generic_alias(return_annotation, generic_input_param, input_annotation)\n    if return_annotation == generic_input_param:\n        return input_annotation.__name__\n    return return_annotation.__name__\n\ndef _match_types(generic, specific, ignore_mismatches=True):\n    if isinstance(generic, TypeVar):\n        return {generic: specific}\n    specific_origin = get_origin(specific)\n    generic_origin = get_origin(generic)\n    if specific_origin is None and generic_origin is None:\n        return {}\n    if (specific_origin is None or generic_origin is None) or not issubclass(specific_origin, generic_origin):\n        if ignore_mismatches:\n            return {}\n        raise Exception(f"Type {generic} does not match with {specific}")\n    generic_args = getattr(generic, "__args__", None)\n    specific_args = getattr(specific, "__args__", None)\n    if specific_args is None and specific_args is None:\n        return {}\n    if generic_args is None:\n        if ignore_mismatches:\n            return {}\n        raise Exception(f"Type {generic} in generic has no arguments")\n    if specific_args is None:\n        if ignore_mismatches:\n            return {}\n        raise Exception(f"Type {specific} in specific has no arguments")\n    if len(generic_args) != len(specific_args):\n        if ignore_mismatches:\n            return {}\n        raise Exception(f"Number of arguments of type {generic} is different in specific type")\n    matches = {}\n    for generic_arg, specific_arg in zip(generic_args, specific_args):\n        matched_types = _match_types(generic_arg, specific_arg)\n        matches.update(matched_types)\n    return matches\n\ndef _specify_types(generic, spec):\n    if isinstance(generic, TypeVar):\n        return spec.get(generic, generic)\n    generic_args = getattr(generic, "__args__", None)\n    if generic_args is None:\n        return generic\n    origin = get_origin(generic)\n    args = tuple(_specify_types(arg, spec) for arg in generic_args)\n    return GenericAlias(origin, args)\n\n_Args = ParamSpec("_Args")\n_R = TypeVar("_R")\n\ndef awaitify(sync_func: Callable[_Args, _R]) -> Callable[_Args, Awaitable[_R]]:\n    async def async_func(*args, **kwargs):\n        return sync_func(*args, **kwargs)\n    return async_func